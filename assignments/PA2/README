README file for Programming Assignment 2 (C++ edition)
=====================================================

Your directory should contain the following files:

 Makefile
 README
 cool.flex
 test.cl
 lextest.cc      -> [cool root]/src/PA2/lextest.cc
 mycoolc         -> [cool root]/PA2/mycoolc
 stringtab.cc    -> [cool root]/PA2/stringtab.cc
 utilities.cc    -> [cool root]/PA2/utilities.cc
 handle_flags.cc -> [cool root]/PA2/handle_flags.cc
 *.d             dependency files
 *.*             other generated files

The include (.h) files for this assignment can be found in 
[cool root]/PA2

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code. Just edit this file.

	cool.flex is a skeleton file for the specification of the
	lexical analyzer. You should complete it with your regular
	expressions, patterns and actions. 

	test.cl is a COOL program that you can test the lexical
	analyzer on. It contains some errors, so it won't compile with
	coolc. However, test.cl does not exercise all lexical
	constructs of COOL and part of your assignment is to rewrite
	test.cl with a complete set of tests for your lexical analyzer.

	cool-parse.h contains definitions that are used by almost all parts
	of the compiler. DO NOT MODIFY.

	stringtab.{cc|h} and stringtab_functions.h contains functions
        to manipulate the string tables.  DO NOT MODIFY.

	utilities.{cc|h} contains functions used by the main() part of
	the lextest program. You may want to use the strdup() function
	defined in here. Remember that you should not print anything
	from inside cool.flex! DO NOT MODIFY.

	lextest.cc contains the main function which will call your
	lexer and print out the tokens that it returns.  DO NOT MODIFY.

	mycoolc is a shell script that glues together the phases of the
	compiler using Unix pipes instead of statically linking code.  
	While inefficient, this architecture makes it easy to mix and match
	the components you write with those of the course compiler.
	DO NOT MODIFY.	

        cool-lexer.cc is the scanner generated by flex from cool.flex.
        DO NOT MODIFY IT, as your changes will be overritten the next
        time you run flex.

 	The *.d files are automatically generated Makefiles that capture
 	dependencies between source and header files in this directory.
 	These files are updated automatically by Makefile; see the gmake
 	documentation for a detailed explanation.

Instructions
------------

	To compile your lextest program type:

	% make lexer

	Run your lexer by putting your test input in a file 'foo.cl' and
	run the lextest program:

	% ./lexer foo.cl

	To run your lexer on the file test.cl type:

	% make dotest

	If you think your lexical analyzer is correct and behaves like
	the one we wrote, you can actually try 'mycoolc' and see whether
	it runs and produces correct code for any examples.
	If your lexical analyzer behaves in an
	unexpected manner, you may get errors anywhere, i.e. during
	parsing, during semantic analysis, during code generation or
	only when you run the produced code on spim. So beware.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA2
================

In this practical the goal is to build a lexical analyzer(scanner) for COOL language 
with FLEX lexical analyzer generator.
FLEX will generate the scanner(C program) using the specifications in the cool.flex file.

Following are the steps followed to implement the scanner.
1. Adding lexical specifications to cool.flex file
2. Generating the scanner using the cool.flex file
3. Testing the scanner generated with sample cool programs.

1. Adding lexical specifications to cool.flex file
--------------------------------------------------

Structure of the .flex file

%{
Declarations    	--> Includes, declaration of variables and signatures of user define 
						functions go here. These are directly copied to the scanner C program. 
						Optional
%}
Definitions	   		--> Regex patterns are named here and they are in the form of ‘name 	pattern’ 
						Optional 
%%
Rules	    		--> Rules specify what action to be taken upon matching the patterns. 
						Rules are defined in the form ‘pattern	action’
%%
User Subroutines   	--> Helper functions are defined here. These are directly copied to the 
						scanner C program.  
						Optional

COOL program lexical structure
------------------------------

- Keywords
- Integers
- Identifiers (Type identifiers and Object identifiers)
- Special syntactic symbols (parentheses, assignment operator, etc)
- Strings
- Comments
- White spaces


- Keywords
----------

Following are the all keywords in the COOL language
- class
- else
- false
- fi
- if
- in
- inherits
- isvoid
- let
- loop
- pool
- then
- while
- case
- esac
- new
- of
- not
- true

Keywords except false and true are case insensitive. The first letter of true and 
false keywords must be lower case and remaining letters are case insensitive.

Regular expression format for keywords except true and false:
(?i:keyword)

Rule for keywords except true and false:
On matching the regex pattern, return the token value defined in cool-parse.h


Regular expression format for true and false:
t(?i:ure)
f(?i:alse)

Rule for keywords true and false:
On matching the regex pattern, assign the respective boolean value to cool_yylval 
and return the token BOOL_CONST


- Integers
----------

Regular expression format for integers:
[0-9]+

Rule for integers:
On matching the regex pattern, create an entry on the inttable, add the integer as 
a string to the created entry and return the token INT_CONST.


- Identifiers (Type identifiers and Object identifiers)
-------------------------------------------------------

Regular expression format for type identifiers:
[A-Z]([a-zA-Z0-9_])*

Rule for type identifiers:
On matching the regex pattern, create an entry on the idtable, add the identifier 
as string to the created entry and return the token TYPEID.

Regular expression format for object identifiers:
[a-z]([a-zA-Z0-9_])*

Rule for object identifiers:
On matching the regex pattern, create an entry on the idtable, add the identifier as
string to the created entry and return the token OBJECTID.


- Special syntactic symbols (parentheses, assignment operator, …)
-----------------------------------------------------------------

Special notations except <-, <= and => returned as it is. For <-, <= and => following 
tokens defined in the cool-parse.h was returned
<-	ASSIGN
<=	LE
=>	DARROW


- Strings
---------

In COOL strings are defined within “ “ (QUOTE). Therefore it is required to use the states
 and the exclusive start condition is defined as STRING. 

Regex pattern for QUOTE is defined as \”. When the scanner is at the INITIAL state and detects
a QUOTE, string_buf and string_bf_ptr are used to store and keep track of the string and it
will go to the STRING state which is the start state for string tokens. 

Once it is at the STRING state and detects any of the following it will do the necessary actions 
to match the COOL language specifications for strings.

\”		append \0 string_buf  to terminate the string, change state to INITIAL, create
		an entry on stringtable, add the string in string_buf and return token STR_CONST.

\0		COOL does not allow NULL character in strings. Therefore, return token ERROR with
		message “String contains null character”

<<EOF>>		COOL does not allow EOF character in strings as strings cannot cross file boundaries. 
			Therefore, return token ERROR with message “EOF in string”.

\n \b \t \f		Check if it exceeds the max string length. If exceed, change state to INITIAL and 
				return ERROR with message “String too long”. If not exceed, add relevant ASCII 
				character to string_buf.

\c where c is not n, b,t, f		Check if it exceeds the max string length. If exceed, change state 
								to INITIAL and return ERROR with message “String too long”. 
								If not exceed, add c to string_buf. Here c represents a character.

c		Check if it exceeds the max string length. If exceed, change state to INITIAL and return 
		ERROR with message “String too long”. If not exceed, add c to string_buf. Here c represents 
		a character.


- Comments
----------

In COOL there are single line and multi line comments. Single line comments start with -- and multi 
line comments are enclose in (* *). There can be nested multi line comments.

Regex for single line comments: 
--.*

Rule for single line comments:
On match, do nothing. This will discard the scanned characters.

For multi line comments, is required to have states and the exclusive start state is defined 
as COMMENT. Since there are nested comments it is required to have a variable comment_dept to 
track of the level of comments.

Regex pattern BEGIN_COMMENT for start of multi line comment is defined as (*. When the scanner 
is at the INITIAL state and detects a BEGIN_COMMENT pattern, comment_depth is increased by 1 
and changes the state to COMMENT which is the start state for comments.

Once it is at the COMMENT state and detects any of the following it will do the necessary actions
to match the COOL language specifications for comments.

(*		increase the comment_depth by 1

*)		decrease the comment_depth by 1 and if the comment_depth is 0 then change to initial state

<<EOF>> 	COOL does not allow EOF character in comments as comments cannot cross file boundaries. 
			Therefore, return token ERROR with message “EOF in comment”.

\n \\n		increase the curr_lineno by 1

When in INITIAL state, if *) was matched, then return token ERROR with message “Unmatched *)”


- White spaces
--------------

White spaces include blank, \n, \f, \r, \t and \v ASCII characters. When \n is detected, 
curr_lineno is increase by 1. When others are detected, nothing is done so that they are discared.



Generating the scanner using the cool.flex file
-------------------------------------------------------

After defining the lexical specifications in the cool.flex file, run ‘make lexer’ command. 
This will generate the scanner.



Testing the scanner generated with sample cool programs
---------------------------------------------------------------------

To test the scanner, run ‘./lexer <cool_program>’. For example, ‘./lexer test.cl’

Following programs where used as test programs,

1. test.cl		- contains EOF in comment error
2. aroi.cl
3. sum.cl		- prints sum from 0 to given input value
				- contains while loops, comments, non escaped newline in strings
4. grader.cl	- prints grade depending on the input marks
				- contains while loops, if contructs